// +build !generator

// Code generated by generator convert. DO NOT EDIT.

package tests

import (
	conversion "github.com/olvrng/ggen-convert/conversion"
)

/*
Custom conversions:
    ConvertAB       // in use
    ConvertC01      // in use
    ConvertC10      // in use

Ignored functions: (none)
*/

func RegisterConversions(s *conversion.Scheme) {
	registerConversions(s)
}

func registerConversions(s *conversion.Scheme) {
	s.Register((*B)(nil), (*A)(nil), func(arg, out interface{}) error {
		Convert_B_A(arg.(*B), out.(*A))
		return nil
	})
	s.Register(([]*B)(nil), (*[]*A)(nil), func(arg, out interface{}) error {
		out0 := Convert_BS_AS(arg.([]*B))
		*out.(*[]*A) = out0
		return nil
	})
	s.Register((*A)(nil), (*B)(nil), func(arg, out interface{}) error {
		Convert_A_B(arg.(*A), out.(*B))
		return nil
	})
	s.Register(([]*A)(nil), (*[]*B)(nil), func(arg, out interface{}) error {
		out0 := Convert_AS_BS(arg.([]*A))
		*out.(*[]*B) = out0
		return nil
	})
	s.Register((*C1)(nil), (*C0)(nil), func(arg, out interface{}) error {
		Convert_C1_C0(arg.(*C1), out.(*C0))
		return nil
	})
	s.Register(([]*C1)(nil), (*[]*C0)(nil), func(arg, out interface{}) error {
		out0 := Convert_C1s_C0s(arg.([]*C1))
		*out.(*[]*C0) = out0
		return nil
	})
	s.Register((*C0)(nil), (*C1)(nil), func(arg, out interface{}) error {
		Convert_C0_C1(arg.(*C0), out.(*C1))
		return nil
	})
	s.Register(([]*C0)(nil), (*[]*C1)(nil), func(arg, out interface{}) error {
		out0 := Convert_C0s_C1s(arg.([]*C0))
		*out.(*[]*C1) = out0
		return nil
	})
	s.Register((*C2)(nil), (*C0)(nil), func(arg, out interface{}) error {
		Convert_C2_C0(arg.(*C2), out.(*C0))
		return nil
	})
	s.Register(([]*C2)(nil), (*[]*C0)(nil), func(arg, out interface{}) error {
		out0 := Convert_C2s_C0s(arg.([]*C2))
		*out.(*[]*C0) = out0
		return nil
	})
	s.Register((*C0)(nil), (*C2)(nil), func(arg, out interface{}) error {
		Convert_C0_C2(arg.(*C0), out.(*C2))
		return nil
	})
	s.Register(([]*C0)(nil), (*[]*C2)(nil), func(arg, out interface{}) error {
		out0 := Convert_C0s_C2s(arg.([]*C0))
		*out.(*[]*C2) = out0
		return nil
	})
	s.Register((*C3)(nil), (*C0)(nil), func(arg, out interface{}) error {
		Convert_C3_C0(arg.(*C3), out.(*C0))
		return nil
	})
	s.Register(([]*C3)(nil), (*[]*C0)(nil), func(arg, out interface{}) error {
		out0 := Convert_C3s_C0s(arg.([]*C3))
		*out.(*[]*C0) = out0
		return nil
	})
	s.Register((*C0)(nil), (*C3)(nil), func(arg, out interface{}) error {
		Convert_C0_C3(arg.(*C0), out.(*C3))
		return nil
	})
	s.Register(([]*C0)(nil), (*[]*C3)(nil), func(arg, out interface{}) error {
		out0 := Convert_C0s_C3s(arg.([]*C0))
		*out.(*[]*C3) = out0
		return nil
	})
	s.Register((*D1)(nil), (*D0)(nil), func(arg, out interface{}) error {
		Convert_D1_D0(arg.(*D1), out.(*D0))
		return nil
	})
	s.Register(([]*D1)(nil), (*[]*D0)(nil), func(arg, out interface{}) error {
		out0 := Convert_D1s_D0s(arg.([]*D1))
		*out.(*[]*D0) = out0
		return nil
	})
	s.Register((*D0)(nil), (*D1)(nil), func(arg, out interface{}) error {
		Convert_D0_D1(arg.(*D0), out.(*D1))
		return nil
	})
	s.Register(([]*D0)(nil), (*[]*D1)(nil), func(arg, out interface{}) error {
		out0 := Convert_D0s_D1s(arg.([]*D0))
		*out.(*[]*D1) = out0
		return nil
	})
}

//-- convert github.com/olvrng/ggen-convert/tests.A --//

func Convert_B_A(arg *B, out *A) *A {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &A{}
	}
	convert_B_A(arg, out)
	return out
}

func convert_B_A(arg *B, out *A) {
	out.Value = out.Value           // types do not match
	out.Int = int64(arg.Int)        // simple conversion
	out.String = string(arg.String) // simple conversion
	out.Strings = arg.Strings       // simple assign
	out.C = Convert_C1_C0(arg.C, nil)
	out.Cs = Convert_C1s_C0s(arg.Cs)
	out.D = Convert_D1_D0(arg.D, nil)
	out.Ds = Convert_D1s_D0s(arg.Ds)
	out.E = arg.E     // simple assign
	out.Ep = arg.Ep   // simple assign
	out.Es = arg.Es   // simple assign
	out.Eps = arg.Eps // simple assign
}

func Convert_BS_AS(args []*B) (outs []*A) {
	if args == nil {
		return nil
	}
	tmps := make([]A, len(args))
	outs = make([]*A, len(args))
	for i := range tmps {
		outs[i] = Convert_B_A(args[i], &tmps[i])
	}
	return outs
}

func Convert_A_B(arg *A, out *B) *B {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &B{}
	}
	ConvertAB(arg, out)
	return out
}

func convert_A_B(arg *A, out *B) {
	out.Value = out.Value      // types do not match
	out.Int = int32(arg.Int)   // simple conversion
	out.String = S(arg.String) // simple conversion
	out.Strings = arg.Strings  // simple assign
	out.C = Convert_C0_C1(arg.C, nil)
	out.Cs = Convert_C0s_C1s(arg.Cs)
	out.D = Convert_D0_D1(arg.D, nil)
	out.Ds = Convert_D0s_D1s(arg.Ds)
	out.E = arg.E     // simple assign
	out.Ep = arg.Ep   // simple assign
	out.Es = arg.Es   // simple assign
	out.Eps = arg.Eps // simple assign
}

func Convert_AS_BS(args []*A) (outs []*B) {
	if args == nil {
		return nil
	}
	tmps := make([]B, len(args))
	outs = make([]*B, len(args))
	for i := range tmps {
		outs[i] = Convert_A_B(args[i], &tmps[i])
	}
	return outs
}

//-- convert github.com/olvrng/ggen-convert/tests.C0 --//

func Convert_C1_C0(arg *C1, out *C0) *C0 {
	return ConvertC10(arg, out)
}

func convert_C1_C0(arg *C1, out *C0) {
	out.Value = out.Value // types do not match
}

func Convert_C1s_C0s(args []*C1) (outs []*C0) {
	if args == nil {
		return nil
	}
	tmps := make([]C0, len(args))
	outs = make([]*C0, len(args))
	for i := range tmps {
		outs[i] = Convert_C1_C0(args[i], &tmps[i])
	}
	return outs
}

func Convert_C0_C1(arg *C0, out *C1) *C1 {
	return ConvertC01(arg)
}

func convert_C0_C1(arg *C0, out *C1) {
	out.Value = out.Value // types do not match
}

func Convert_C0s_C1s(args []*C0) (outs []*C1) {
	if args == nil {
		return nil
	}
	tmps := make([]C1, len(args))
	outs = make([]*C1, len(args))
	for i := range tmps {
		outs[i] = Convert_C0_C1(args[i], &tmps[i])
	}
	return outs
}

func Convert_C2_C0(arg *C2, out *C0) *C0 {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &C0{}
	}
	convert_C2_C0(arg, out)
	return out
}

func convert_C2_C0(arg *C2, out *C0) {
	*out = arg.C0 // embedded struct
}

func Convert_C2s_C0s(args []*C2) (outs []*C0) {
	if args == nil {
		return nil
	}
	tmps := make([]C0, len(args))
	outs = make([]*C0, len(args))
	for i := range tmps {
		outs[i] = Convert_C2_C0(args[i], &tmps[i])
	}
	return outs
}

func Convert_C0_C2(arg *C0, out *C2) *C2 {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &C2{}
	}
	convert_C0_C2(arg, out)
	return out
}

func convert_C0_C2(arg *C0, out *C2) {
	out.C0 = *arg // embedded struct
	out.X = out.X // no change
	out.Y = out.Y // no change
	out.Z = out.Z // no change
}

func Convert_C0s_C2s(args []*C0) (outs []*C2) {
	if args == nil {
		return nil
	}
	tmps := make([]C2, len(args))
	outs = make([]*C2, len(args))
	for i := range tmps {
		outs[i] = Convert_C0_C2(args[i], &tmps[i])
	}
	return outs
}

func Convert_C3_C0(arg *C3, out *C0) *C0 {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &C0{}
	}
	convert_C3_C0(arg, out)
	return out
}

func convert_C3_C0(arg *C3, out *C0) {
	*out = *arg.C0 // embedded struct
}

func Convert_C3s_C0s(args []*C3) (outs []*C0) {
	if args == nil {
		return nil
	}
	tmps := make([]C0, len(args))
	outs = make([]*C0, len(args))
	for i := range tmps {
		outs[i] = Convert_C3_C0(args[i], &tmps[i])
	}
	return outs
}

func Convert_C0_C3(arg *C0, out *C3) *C3 {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &C3{}
	}
	convert_C0_C3(arg, out)
	return out
}

func convert_C0_C3(arg *C0, out *C3) {
	out.C0 = new(C0) // embedded struct
	*out.C0 = *arg   // embedded struct
	out.X = out.X    // no change
	out.Y = out.Y    // no change
	out.Z = out.Z    // no change
}

func Convert_C0s_C3s(args []*C0) (outs []*C3) {
	if args == nil {
		return nil
	}
	tmps := make([]C3, len(args))
	outs = make([]*C3, len(args))
	for i := range tmps {
		outs[i] = Convert_C0_C3(args[i], &tmps[i])
	}
	return outs
}

//-- convert github.com/olvrng/ggen-convert/tests.D0 --//

func Convert_D1_D0(arg *D1, out *D0) *D0 {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &D0{}
	}
	convert_D1_D0(arg, out)
	return out
}

func convert_D1_D0(arg *D1, out *D0) {
	out.Value = arg.Value // simple assign
}

func Convert_D1s_D0s(args []*D1) (outs []*D0) {
	if args == nil {
		return nil
	}
	tmps := make([]D0, len(args))
	outs = make([]*D0, len(args))
	for i := range tmps {
		outs[i] = Convert_D1_D0(args[i], &tmps[i])
	}
	return outs
}

func Convert_D0_D1(arg *D0, out *D1) *D1 {
	if arg == nil {
		return nil
	}
	if out == nil {
		out = &D1{}
	}
	convert_D0_D1(arg, out)
	return out
}

func convert_D0_D1(arg *D0, out *D1) {
	out.Value = arg.Value // simple assign
}

func Convert_D0s_D1s(args []*D0) (outs []*D1) {
	if args == nil {
		return nil
	}
	tmps := make([]D1, len(args))
	outs = make([]*D1, len(args))
	for i := range tmps {
		outs[i] = Convert_D0_D1(args[i], &tmps[i])
	}
	return outs
}
